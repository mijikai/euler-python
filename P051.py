#!/usr/bin/env python3
"""Find a prime that when some of its digits is substituted by the same digits,
8 different primes are generated. For example 13 can form 6 different primes
because, 13, 23, 43, 53, 73, and 83 are primes when 1 is substituted by
another."""
from functools import reduce, lru_cache
from utils import powerset, runner
from num_theory import sieve_of_eratosthenes

def same_digit(digits, pos):
    """Returns true if a the tuple of digits has the same digit in the position
    given by the tuple pos. The indexing is from the leftmost digit and starts
    from zero.
    Example:
    >>> same_digit((1,2,3,2), (1,3))
    True
    """
    dig = digits[pos[0]]
    return all(map(lambda ind: digits[ind] == dig, pos))


def digit_iter(integer):
    """Returns an iterable of digits starting from the left of integer.
    Example:
    >>> list(digit_iter(1234))
    [1, 2, 3, 4]
    """
    assert integer > 0
    return map(int, str(integer))


@lru_cache(maxsize=None)
def prime_replace_part(digits, pos, replacer, primes):
    """Returns the number of primes by generated by replacing the digits at
    the positions given by pos with the replacer ... 9.
    Arguments:
    digits - the list of digits
    pos - an tuple of the position to be replace starting from the leftmost
        zero with zero indexing.
    replacer - the starting value of the digit that will be substitute with.
    primes - a collection of primes to be check with.
    Example:
    >>> primes = (2, 3, 5, 7, 11, 13, 17, 23, 29, 31, 37, 41, 43, 47, 53,
        59, 61, 67, 71, 73, 79, 83, 89, 97)
    >>> prime_replace_part((1, 3), (0,), 1, primes) # 13, 23, 43, 53, 73, 83
    6
    """
    if replacer > 9:
        return 0
    new_digits = list(digits)
    for i in pos:
        new_digits[i] = replacer
    new_digits = tuple(new_digits)

    num = reduce(lambda a, b: 10 * a + b, new_digits, 0)
    res = 0
    if num in primes:
        res = 1
    return res + prime_replace_part(new_digits, pos, replacer + 1, primes)


def prog(limit, primes):
    p = frozenset(primes)
    for i in primes:
        digits = tuple(digit_iter(i))
        maxdig = max(digits)
        positions = powerset(range(len(digits)))
        next(positions)
        for j in positions:
            if same_digit(digits, j):
                dig = digits[j[0]]
                if prime_replace_part(digits, j, dig, p) == 8:
                    return i


def main():
    print(prog(8, tuple(sieve_of_eratosthenes(10 ** 6))))


if __name__ == '__main__':
    runner('main')
